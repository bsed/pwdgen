// Copyright 2014 MortalSkulD@gmail.com. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ingore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"runtime"
	"sort"
	"strings"
)

var (
	flagOutput = flag.String("output", "pwdgen.go", "output file name")
	flagGOOS   = flag.String("goos", runtime.GOOS, "operating system target(windows|linux|darwin)")
)

func main() {
	flag.Parse()

	var goFiles = getAllFiles()
	var out bytes.Buffer

	// gen copyright and package doc
	fmt.Fprintf(&out, `
// Copyright 2014 MortalSkulD@gmail.com. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Auto Generated By 'go generate', DONOT EDIT!!!

// +build ingore
// +build %s

%s
package main

`[1:],
		*flagGOOS,
		readPkgDoc(),
	)

	// gen imports
	fmt.Fprintf(&out, "import (\n")
	imports := readImports(goFiles)
	for i := 0; i < len(imports); i++ {
		fmt.Fprintf(&out, "\t%s\n", imports[i])
	}
	fmt.Fprintf(&out, ")\n\n")

	for i := 0; i < len(goFiles); i++ {
		fmt.Fprintf(&out, "%s\n", readFile(goFiles[i]))
	}

	data, err := format.Source(out.Bytes())
	if err != nil {
		log.Printf("format.Source: err = %v", err)
		log.Fatalf("format.Source: err = %v", err)
	}
	err = ioutil.WriteFile(*flagOutput, data, 0644)
	if err != nil {
		log.Fatalf("ioutil.WriteFile: err = %v", err)
	}

	fmt.Printf("Generate %s for %s done\n", *flagOutput, *flagGOOS)
}

func getAllFiles() []string {
	var baseFiles = []string{
		"main.go",
		"ini.go",
		"ini_dict.go",
		"base58.go",
		"get_passwd.go",
		"conf.go",
	}
	var windowsFiles = []string{
		"get_passwd_windows.go",
	}
	var posixFiles = []string{
		"get_passwd_posix.go",
	}

	var files []string
	for i := 0; i < len(baseFiles); i++ {
		files = append(files, baseFiles[i])
	}
	if *flagGOOS == "windows" {
		for i := 0; i < len(windowsFiles); i++ {
			files = append(files, windowsFiles[i])
		}
	} else {
		for i := 0; i < len(posixFiles); i++ {
			files = append(files, posixFiles[i])
		}
	}
	return files
}

func readPkgDoc() string {
	data, err := ioutil.ReadFile("doc.go")
	if err != nil {
		log.Fatalf("readPkgDoc: ioutil.ReadFile, %v", err)
	}
	if idxDoc := bytes.Index(data, []byte("\n\n")); idxDoc >= 0 {
		data = data[idxDoc:]
	}
	if idxPkg := bytes.Index(data, []byte("\npackage")); idxPkg >= 0 {
		data = data[:idxPkg]
	}
	return string(data)
}

func readImports(files []string) []string {
	var imports []string
	for i := 0; i < len(files); i++ {
		imports = append(imports, readFileImports(files[i])...)
	}
	var importMap = make(map[string]bool)
	for i := 0; i < len(imports); i++ {
		importMap[imports[i]] = true
	}
	imports = make([]string, 0, len(importMap))
	for k, _ := range importMap {
		imports = append(imports, k)
	}
	sort.Strings(imports)
	return imports
}

func readFileImports(filename string) []string {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		log.Fatalf("readFileImports: ioutil.ReadFile, %v", err)
	}
	if idxImportStart := bytes.Index(data, []byte("import (")); idxImportStart >= 0 {
		data = data[idxImportStart+len("import ("):]
	} else {
		return nil
	}
	if idxImportEnd := bytes.Index(data, []byte(")")); idxImportEnd >= 0 {
		data = data[:idxImportEnd]
	} else {
		return nil
	}
	lines := strings.Split(string(data), "\n")
	for i := 0; i < len(lines); i++ {
		lines[i] = strings.TrimSpace(lines[i])
		if lines[i] == "" {
			lines[i] = lines[len(lines)-1]
			lines = lines[:len(lines)-1]
			i--
		}
	}
	return lines
}

func readFile(filename string) string {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		log.Fatalf("readFile: ioutil.ReadFile, %v", err)
	}

	if idxPkg := bytes.Index(data, []byte("package main")); idxPkg >= 0 {
		data = data[idxPkg+len("package main"):]
	}

	if idxImportStart := bytes.Index(data, []byte("import (")); idxImportStart >= 0 {
		data = data[idxImportStart+len("import ("):]
		if idxImportEnd := bytes.Index(data, []byte(")")); idxImportEnd >= 0 {
			data = data[idxImportEnd+len(")"):]
		} else {
			log.Fatalf("readFile: not found import end")
		}
	}
	return string(data)
}
